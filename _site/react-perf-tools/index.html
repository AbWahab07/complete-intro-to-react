<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />

  <title>Complete Intro to React</title>
  <meta name="description" content="A Complete Intro to React, as taught for FrontendMasters.com
">
  <meta name="keywords" content="" />

  <meta name="HandheldFriendly" content="True" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <link rel="stylesheet" type="text/css" href="../css/main.css" />
  <link rel="stylesheet" type="text/css" href="../css/elements.css" />
  <link rel="stylesheet" type="text/css" href="../css/layout.css" />
  <link rel="stylesheet" type="text/css" href="../css/highlight.css" />
</head>
<body class="post-template">

  <header class="main-header">
    <div class="vertical">
      <div class="main-header-content">
        <h1 class="page-title">
          <a href="../">Complete Intro to React</a>
        </h1>
      </div>
    </div>
  </header>

  <main id="content" class="content" role="main">
    

<article class="post">

  <header class="post-header">
    <section class="post-meta">
      <time class="post-date" datetime=""></time>
      <span>&middot; </span>
    </section>
  </header>

  <section class="post-content">
    <p>As you app continues to grow, sometimes slow code paths can start to emerge. React is pretty good about being performant under normal loads but even React has its limits. One of the ways this can manifest itself is how often components are running through the re-render process without actually changing anything. These are called wasted renders. Normally you don't have to actually to worry about this: React handles a lot of wasted re-renders without slowing down the app at all and you can spend your time building features instead. It's helpful to glance at your performance data every once in a while but don't dwell too much on it.</p>
<p>So, as it stands, our code actually does have a code path that we can optimize. So let's go explore how we discover the problem and ultimately fix it.</p>
<p>First, open ClientApp.jsx and add:</p>
<pre><code class="language-javascript"><span class="hljs-comment">// before App import</span>
<span class="hljs-keyword">import</span> Perf <span class="hljs-keyword">from</span> <span class="hljs-string">'react-addons-perf'</span>;

<span class="hljs-comment">// after App import</span>
<span class="hljs-built_in">window</span>.Perf = Perf;
Perf.start();
</code></pre>
<p>This is temporary code. You do not want to ship this in production. We'll use this to profile our code, get the useful info out of it and then remove it since it'd just be dead bloat in production.</p>
<p>So what we've done is import the React perf tools which will automatically hook into your React instance and track wasted renders for you. We're just setting it on the global window object so we can manipulate it directly in the console.</p>
<p>Now open your browser, and navigate around you webpage a bunch. Visit all the various ShowCard components, visit the home route, enter some search terms, delete the terms, enter different ones, etc. You want to cause the UI to change in all the various ways that are possible so we can see the slow code paths.</p>
<p>After you've sufficiently prodded your app, open you console and enter: <code>Perf.stop()</code> followed by <code>Perf.printWasted()</code>. You see a console table of the various wasted renders sorted by how many milliseconds are being wasted. Based on this you can find hot code paths and see what you can do to fix tihs.</p>
<p>In our case, it jumps out that our ShowCard is the greatest offender here: it's a component that once rendered never changes. There's nothing dynamic about any individual ShowCard. Armed with this information, there's an easy optimization to make here: shouldComponentUpdate.</p>
<p>Open ShowCard.jsx. Right now it's a function component so we can't add a lifecycle method like shouldComponentUpdate so we'll have to convert it to a class. Change the component to be:</p>
<pre><code class="language-javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShowCard</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>{
  shouldComponentUpdate() {
    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  }
  props: {
    <span class="hljs-attr">poster</span>: string,
    <span class="hljs-attr">title</span>: string,
    <span class="hljs-attr">year</span>: string,
    <span class="hljs-attr">description</span>: string,
    <span class="hljs-attr">imdbID</span>: string,
  };
  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">Wrapper</span> <span class="hljs-attr">to</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">details</span>/${<span class="hljs-attr">this.props.imdbID</span>}`}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">Image</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">{</span>`${<span class="hljs-attr">this.props.title</span>} <span class="hljs-attr">Show</span> <span class="hljs-attr">Poster</span>`} <span class="hljs-attr">src</span>=<span class="hljs-string">{</span>`/<span class="hljs-attr">public</span>/<span class="hljs-attr">img</span>/<span class="hljs-attr">posters</span>/${<span class="hljs-attr">this.props.poster</span>}`} /&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>{this.props.title}<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">h4</span>&gt;</span>({this.props.year})<span class="hljs-tag">&lt;/<span class="hljs-name">h4</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>{this.props.description}<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
      <span class="hljs-tag">&lt;/<span class="hljs-name">Wrapper</span>&gt;</span>
    );
  }
}
</span></code></pre>
<p>Now whenever React goes to see if an individual instance of a ShowCard has changed, it'll run this function instead of running the render function and diffing against the last run of the render function. As you may imagine, this will go a lot faster.</p>
<p>Let's talk about the mechanics of shouldComponentUpdate. Almost all of the times I personally have used it, it has been just what you've seen here: returing false to ensure a component that doesn't needs to update doesn't go through the diffing process. There is a more advanced use case where perhaps updates only rely on a few pieces of state, props, or anything else. Here in shouldComponentUpdate, you could check those and only re-render if those changed. See the <a href="https://facebook.github.io/react/docs/optimizing-performance.html#shouldcomponentupdate-in-action">React docs</a> for more info.</p>
<p>Go back and profile your App again with the perf tools. You'll notice that ShowCard has disappeared from it.</p>
<p>This is a powerful and potentially bug-causing tool for you. Fathom later that we had dynamic content to ShowCard. If you call setState, nothing will happen until you remove or modify that shouldComponentUpdate method. Many people once they learn about shouldComponentUpdate will put it everywhere: don't. You'll cause more issues than you'll solve trying to solve perf problems that don't exist. React is normally fast enough as-is.</p>

  </section>

  <footer class="post-footer">
  </footer>

</article>



    
  </main>

  <footer class="site-footer clearfix">
    <p class="footer-description">
      &copy; Complete Intro to React
    </p>
    <p class="footer-published">
      joyfully published by <a href="https://github.com/reptar/reptar">reptar</a>
    </p>
  </footer>

</body>
</html>
